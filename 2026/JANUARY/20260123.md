# 20260123

등록일: 2026년 1월 23일 오전 6:08

## 둘만의 암호

### **문제 설명**

두 문자열 `s`와 `skip`, 그리고 자연수 `index`가 주어질 때, 다음 규칙에 따라 문자열을 만들려 합니다. 암호의 규칙은 다음과 같습니다.

- 문자열 `s`의 각 알파벳을 `index`만큼 뒤의 알파벳으로 바꿔줍니다.
- `index`만큼의 뒤의 알파벳이 `z`를 넘어갈 경우 다시 `a`로 돌아갑니다.
- `skip`에 있는 알파벳은 제외하고 건너뜁니다.

예를 들어 `s` = "aukks", `skip` = "wbqd", `index` = 5일 때, a에서 5만큼 뒤에 있는 알파벳은 f지만 [b, c, d, e, f]에서 'b'와 'd'는 `skip`에 포함되므로 세지 않습니다. 따라서 'b', 'd'를 제외하고 'a'에서 5만큼 뒤에 있는 알파벳은 [c, e, f, g, h] 순서에 의해 'h'가 됩니다. 나머지 "ukks" 또한 위 규칙대로 바꾸면 "appy"가 되며 결과는 "happy"가 됩니다.

두 문자열 `s`와 `skip`, 그리고 자연수 `index`가 매개변수로 주어질 때 위 규칙대로 `s`를 변환한 결과를 return하도록 solution 함수를 완성해주세요.

---

### 제한사항

- 5 ≤ `s`의 길이 ≤ 50
- 1 ≤ `skip`의 길이 ≤ 10
- `s`와 `skip`은 알파벳 소문자로만 이루어져 있습니다.
    - `skip`에 포함되는 알파벳은 `s`에 포함되지 않습니다.
- 1 ≤ `index` ≤ 20

---

### 입출력 예

| s | skip | index | result |
| --- | --- | --- | --- |
| "aukks" | "wbqd" | 5 | "happy" |

---

### 입출력 예 설명

입출력 예 #1

본문 내용과 일치합니다.

---

### 정답

- 시도1
    
    ```python
    import string
    
    def solution(s, skip, index):
        a = string.ascii_lowercase
        
        # skip 문자 제거
        repa = ''.join(c for c in a if c not in skip)
        
        # 순환을 위해 2배
        repa *= 2
        
        answer = []
        for ch in s:
            idx = repa.index(ch)
            answer.append(repa[idx + index])
        
        return ''.join(answer)
    ```
    
    → 런타임 에러 발생
    
    repa는 skip을 제거한 알파벳 집합인데, 만약 ch가 다음 중 하나면 repa에 없다.
    
    - ch가 skip에 포함됨 (예: skip=“wbqd”, ch=“w”)
    - ch가 소문자 a-z가 아님 (예: 대문자, 숫자, 공백)
    - skip이 너무 많아서 repa가 비정상(거의 없음)인 케이스
    
    즉 존재하지 않는 문자의 위치를 찾으려고 해서 런타임 에러 발생
    
- 수정
    
    ```python
    import string
    
    def solution(s, skip, index):
        alpha = string.ascii_lowercase
        repa = ''.join(c for c in alpha if c not in skip)
        n = len(repa)
    
        pos = {c:i for i, c in enumerate(repa)}  
        
        answer = []
        for ch in s:
            if ch not in pos:
                answer.append(ch)
                continue
            answer.append(repa[(pos[ch] + index) % n])
    
        return ''.join(answer)
    ```
    
    → 위치표를 먼저 만든다
    
    ```python
    pos = {c:i for i, c in enumerate(repa)}
    ```
    
    → 넘어가는 문자, 기존 string 두배가 아닌 나머지 활용
    
    ```python
    repa[(pos[ch] + index) % n]
    ```